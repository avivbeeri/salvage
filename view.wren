import "dome" for Window
import "graphics" for Canvas, Color, ImageData
import "input" for Keyboard
import "math" for M, Vec
import "./action" for PlayerMoveAction,
  DanceAction,
  RestAction,
  ChargeWeaponAction,
  FireWeaponAction
import "./events" for GameOverEvent, MoveEvent, LogEvent
import "./model" for GameModel
import "./keys" for Key


var TILE_WIDTH = 8
var TILE_HEIGHT = 8

var Inputs = [
  "left",
  "right",
  "up",
  "down"
].map {|key| Key.new(key, PlayerMoveAction.new(key), true) }.toList
Inputs.add(Key.new("space", RestAction.new(), true))
Inputs.add(Key.new("d", DanceAction.new(), true))
Inputs.add(Key.new("c", ChargeWeaponAction.new(), false))
Inputs.add(Key.new("f", FireWeaponAction.new(), false))


class Animation {
  done=(v) { _done = v }
  done { _done || false }
  t { _t || 0 }
  update(view) { _t = t + 1 }
  draw() {}
}

class WaitAnimation is Animation {
  construct begin() {
  }
  update(view) {
    super.update(view)
    if (t > 60) {
      done = true
    }
  }
}

class CameraAnimation is Animation {
  construct begin() {
  }
  update(view) {
    var player = view.model.player
    var camera = view.camera
    camera.x = (camera.x - M.sign(camera.x - player.x) * (1/ TILE_WIDTH))
    camera.y = (camera.y - M.sign(camera.y - player.y) * (1/ TILE_HEIGHT))

    if ((camera.x - player.x).abs < 0.1 && (camera.y - player.y).abs < 0.1) {
      done = true
      camera.x = M.round(camera.x)
      camera.y = M.round(camera.y)
    }
  }
}



class GameView {
  construct init(gameModel) {
    Window.title = "Salvage"
    var scale = 3
    Canvas.resize(128+64, 128 + 64)
    Window.resize(scale * Canvas.width, scale * Canvas.height)

    _model = gameModel
    _log = []
    _events = []
    _animations = [ WaitAnimation.begin() ]
    _ready = true
    updateState()

    _camera = Vec.new(_model.player.x, _model.player.y)
  }
  camera { _camera }
  model { _model }

  update() {
    _ready = _animations.count == 0

    Inputs.each { |input| input.update() }
    if (_ready) {
      if (_gameOver) {
      }
      for (input in Inputs) {
        if (input.firing) {
          _model.player.action = input.action
          break
        }
      }
      var result = _model.process()
      _ready = _ready && !result.progress && result.events.count == 0
      _animations = processEvents(result.events)
    } else {
      _animations[0].update(this)
      if (_animations[0].done) {
        updateState()
        _animations.removeAt(0)
      }
    }
  }

  // Following the Redux model, you can up
  updateState() {
    _currentMap = _model.map
    _currentEnergy = _model.energy
    _gameOver = _gameOverImminent || false
  }

  // Respond to events generated by the Game Model since the last action was taken
  // You can trigger animations here and pass them back to the view
  processEvents(events) {
    return events.map {|event|
      if (event is GameOverEvent) {
        _gameOverImminent = true
        return null
      } else if (event is LogEvent) {
        _log.add(event.text)
        _log = _log.skip(M.max(0, _log.count - 3)).toList
      } else if (event is MoveEvent) {
        if (event.source == _model.player) {
          return CameraAnimation.begin()
        }
      }
      return null
    }.where {|animation| animation != null }.toList
  }

  draw() {
    Canvas.cls()
    var map = _currentMap
    if (_gameOver) {
      // TODO UI Stacking system
      Canvas.print("Game Over", 0, map.height * 8, Color.white)
    } else {
      // Canvas.print("Player: %(_model.entities[0].energy)", 0,8, Color.white)
      // Canvas.print("Blob: %(_model.entities[1].energy)", 0, 0, Color.white)
    }
    var player = _model.player


    var displayW = 128
    var displayH = 128
    var top = (Canvas.height - displayH) / 2
    var left = 4
    var offX = left + (displayW / 2) - (camera.x * TILE_WIDTH) - 4
    var offY = top + (displayH / 2) - (camera.y * TILE_HEIGHT) - 4

    var border = 8
    var minX = M.max(player.x - border, 0)
    var maxX = M.min(player.x + border, map.width)
    var minY = M.max(player.y - border, 0)
    var maxY = M.min(player.y + border, map.height)


    for (y in minY...maxY) {
      for (x in minX...maxX) {
        var tile = map.get(x, y)
        if (tile["light"] > 0) {
        // if (!tile["dark"] && (Vec.new(x, y) - camera).length < border) {
          if (tile.type == ".") {
            Canvas.print(".", offX + x * TILE_WIDTH, offY + y * TILE_HEIGHT, Color.darkgray)
          } else if (tile.type == "#") {
            Canvas.print("#", offX + x * TILE_WIDTH, offY + y * TILE_HEIGHT, Color.darkgray)
            // Canvas.rectfill(offX + x * 8, offY + y * 8, 7, 8, Color.darkgray)
          } else if (tile.type == "*") {
            Canvas.print("*", offX + x * TILE_WIDTH, offY + y * TILE_HEIGHT, Color.blue)
          } else if (tile.type == "~") {
            Canvas.rectfill(offX + x * TILE_WIDTH, offY + y * TILE_HEIGHT, 7, 8, Color.brown)
            Canvas.print("~", offX + x * TILE_WIDTH, offY + y * TILE_HEIGHT + 3, Color.white)
          } else if (tile.type == "+") {
            // What kind of door is it?
            var color = Color.darkgreen
            if (tile["locked"]) {
              color = Color.hex("#800000")
            }
            Canvas.rectfill(offX + x * TILE_WIDTH, offY + y * TILE_HEIGHT, 7, 8, color)
            Canvas.print("+", offX + x * TILE_WIDTH, offY + y * TILE_HEIGHT, Color.black)
          }
        }
      }
    }

    _model.entities.each {|entity|
      var diff = entity.pos - camera
      if (!entity.visible ||
        (entity.x >= maxX) || entity.x < minX ||
        (entity.y >= maxY) || entity.y < minY) {
        return
      }
      if (entity.type == "player") {
        Canvas.rectfill(offX + TILE_WIDTH * camera.x, offY + TILE_HEIGHT * camera.y, TILE_WIDTH, TILE_HEIGHT, Color.rgb(0, 0, 0, 128))
        Canvas.print("@", offX + TILE_WIDTH * camera.x, offY + TILE_HEIGHT * camera.y, Color.white)
      } else if (entity.type == "blob") {
        Canvas.print("s", offX + TILE_WIDTH * entity.x, offY + TILE_HEIGHT * entity.y, Color.green)
      } else if (entity.type == "chargeball") {
        if (entity.state == "charging") {
          var diff = entity.pos - player.pos
          Canvas.print("o", offX + TILE_WIDTH * (camera.x + diff.x), offY + TILE_HEIGHT * (camera.y +  diff.y), Color.blue)
        } else {
          Canvas.print("o", offX + TILE_WIDTH * (entity.x), offY + TILE_HEIGHT * (entity.y), Color.blue)
        }
      }
    }
    Canvas.rectfill(left, top - 12, displayW, TILE_HEIGHT, Color.black)

    // Render one animation at a time
    if (_animations.count > 0) {
      _animations[0].draw()
    }

    Canvas.rectfill(129, top, 64, Canvas.height, Color.black)
    Canvas.line(129, top, 129, Canvas.height, Color.purple)
    var lineY = 0
    for (line in _log) {
      Canvas.print(line, 0, lineY, Color.white)
      lineY = lineY + 8
    }

    Canvas.print("[", 0, top + 128, Color.white)
    for (pip in 0...(player.power / 40).ceil) {
      Canvas.print("|", 3 * (1 + pip), top + 128, Color.blue)
    }
    Canvas.print("]", 8 + 3 * 38, top + 128, Color.white)
    Canvas.print(player.power.toString, 0, top + 136, Color.white)
  }

}

